<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒã‚®åç©«ã‚²ãƒ¼ãƒ </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background-color: #f7f3e9;
      color: #553322;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      background-image: url("images/bg_negi_field.png");
      background-size: cover;
      background-position: center;
    }

    .wrapper {
      max-width: 480px;
      margin: 0 auto;
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* HUD */
    .hud { text-align: center; padding: 10px 0 6px; }

    .score {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.08em;
      padding: 6px 12px;
      border-radius: 999px;
      border: 2px solid #ffb15a;
      display: inline-block;
      background: rgba(255, 248, 235, 0.92);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12);
    }
    .score span { min-width: 64px; display: inline-block; text-align: right; }

    .life-bar {
      margin: 6px auto 0;
      display: inline-block;
      padding: 8px 12px;
      border-radius: 999px;
      border: 2px solid #e2c9a3;
      background: rgba(255, 255, 255, 0.78);
      font-size: 14px;
      font-weight: 900;
      letter-spacing: 0.05em;
    }

    /* å¤§ãã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºã‚¾ãƒ¼ãƒ³ï¼ˆèª¬æ˜ï¼†ã‚³ãƒ¡ãƒ³ãƒˆï¼‰ */
    #rule-text {
      text-align: center;
      font-size: 1.15rem;
      line-height: 1.65;
      color: #553322;
      font-weight: 900;
      margin: 10px 12px 0;
      padding: 12px 12px;
      background: rgba(255, 255, 255, 0.72);
      border-radius: 14px;
      backdrop-filter: blur(4px);
      min-height: 3.4em;
      box-shadow: 0 2px 10px rgba(0,0,0,0.10);
    }
    .rule-flash {
      outline: 3px solid rgba(255, 177, 90, 0.55);
      transform: translateY(-1px);
    }

    .invincible .score {
      animation: glow 0.6s ease-in-out infinite alternate;
      border-color: #ffd700;
    }
    @keyframes glow {
      from { box-shadow: 0 0 6px rgba(255, 215, 0, 0.5); }
      to   { box-shadow: 0 0 14px rgba(255, 215, 0, 1); }
    }

    /* GAME AREA */
    #game-area {
      position: relative;
      flex: 1;
      overflow: hidden;
      background-image: url("images/bg_negi_field.png");
      background-size: cover;
      background-position: center bottom;
      border-top: 2px solid #e2c9a3;
      border-bottom: 2px solid #e2c9a3;
    }

    /* ãƒã‚®ã¯ãƒ©ãƒƒãƒ‘ãƒ¼ã§æŒã¤ï¼ˆå›å¾©ãƒ©ãƒ™ãƒ«ä»˜ã‘ã‚‹ãŸã‚ï¼‰ */
    .leek-wrap {
      position: absolute;
      bottom: 6vh;
      left: -200px;
      width: 30vw;
      min-width: 120px;
      max-width: 220px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      cursor: pointer;
    }

    .leek-img {
      width: 100%;
      display: block;
      transition: transform 0.08s;
      user-select: none;
      -webkit-user-drag: none;
    }
    .leek-wrap:active .leek-img {
      transform: translateY(3px) scale(0.97);
    }

    /* å›å¾©ãƒãƒƒã‚¸ï¼ˆãƒãƒ¼ãƒˆç‚¹æ»…ï¼‰ */
    .heal-badge {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      font-weight: 900;
      padding: 6px 10px;
      border-radius: 999px;
      color: #2f6b3a;
      background: rgba(235, 255, 240, 0.95);
      border: 2px solid rgba(70, 170, 90, 0.55);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      display: none;
      white-space: nowrap;
    }
    .leek-wrap.heal .heal-badge { display: inline-block; }

    .heal-heart {
      display: inline-block;
      margin-left: 6px;
      animation: blinkHeart 0.7s ease-in-out infinite alternate;
    }
    @keyframes blinkHeart {
      from { transform: scale(1.0); filter: brightness(1.0); }
      to   { transform: scale(1.18); filter: brightness(1.3); }
    }

    /* ç”»é¢å†…ãƒãƒƒãƒ— */
    .pop {
      position: absolute;
      pointer-events: none;
      font-weight: 900;
      font-size: 18px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(255, 177, 90, 0.75);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      transform: translate(-50%, -50%);
      animation: popUp 0.75s ease-out forwards;
      white-space: nowrap;
    }
    @keyframes popUp {
      0%   { opacity: 0; transform: translate(-50%, -35%) scale(0.95); }
      15%  { opacity: 1; transform: translate(-50%, -50%) scale(1.00); }
      100% { opacity: 0; transform: translate(-50%, -95%) scale(1.03); }
    }

    /* CONTROLS */
    .controls { padding: 12px 16px 18px; text-align: center; }

    .btn-main {
      display: inline-block;
      width: min(360px, 92%);
      padding: 14px 18px;
      border-radius: 18px;
      border: none;
      background: linear-gradient(180deg, #ffb15a, #ff8b3d);
      color: #fff;
      font-size: 22px;
      font-weight: 900;
      letter-spacing: 0.08em;
      box-shadow: 0 6px 0 #d96c23;
      cursor: pointer;
    }
    .btn-main:active { transform: translateY(2px); box-shadow: 0 4px 0 #d96c23; }
  </style>
</head>

<body>
  <div class="wrapper">
    <header class="hud">
      <div class="score">
        SCORE: <span id="score-value">0</span>
      </div>

      <div class="life-bar">
        ãƒ©ã‚¤ãƒ•: <span id="life-value">7</span> / 7ã€€ï½œã€€ã‚³ãƒ³ãƒœ: <span id="combo-value">0</span>ã€€ï½œã€€æœ€é«˜: <span id="best-value">0</span>
      </div>

      <div id="rule-text"></div>
    </header>

    <main id="game-area"></main>

    <footer class="controls">
      <!-- ãƒœã‚¿ãƒ³ã¯1å€‹ã ã‘ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾Œã«æ–‡è¨€ãŒå¤‰ã‚ã‚‹ï¼‰ -->
      <button id="main-btn" class="btn-main">åç©«é–‹å§‹ï¼</button>
    </footer>
  </div>

  <script>
    // ====== ç”»åƒè¨­å®š ======
    const NEGI_TYPES = {
      good: [
        { name: "ç´°ãƒã‚®",  file: "negi_hoso.png" },
        { name: "æ™®é€šãƒã‚®", file: "negi_futsu.png" },
        { name: "å¤ªãƒã‚®",  file: "negi_futo.png" }
      ],
      bad: [
        { name: "æ¯ã‚Œãƒã‚®", file: "negi_kare.png" },
        { name: "æŠ˜ã‚Œãƒã‚®", file: "negi_ore.png" }
      ],
      gold: [
        { name: "é‡‘ãƒã‚®", file: "negi_gold.png" }
      ],
      heal: [
        { name: "å›å¾©æŸãƒã‚®", file: "negi_taba.png" }
      ]
    };

    // ====== DOM ======
    const gameArea = document.getElementById("game-area");
    const scoreValueEl = document.getElementById("score-value");
    const lifeValueEl = document.getElementById("life-value");
    const comboValueEl = document.getElementById("combo-value");
    const bestValueEl = document.getElementById("best-value");
    const ruleTextEl = document.getElementById("rule-text");
    const mainBtn = document.getElementById("main-btn");
    const bodyEl = document.body;

    // ====== èª¬æ˜æ–‡ï¼ˆä¸Šã«è¡¨ç¤ºï¼‰ ======
    const DEFAULT_RULE_HTML =
      'æ¯ã‚Œãƒã‚®ãƒ»æŠ˜ã‚Œãƒã‚®ã‚’ã‚¿ãƒƒãƒ—ã—ã¦å–ã‚Šé™¤ã“ã†ï¼<br>' +
      'é‡‘ãƒã‚®ã¯ã‚¿ãƒƒãƒ—ã§ <b>+10ç‚¹</b> ï¼† <b>5ç§’é–“ãƒãƒ¼ãƒšãƒŠãƒ«ãƒ†ã‚£</b>âœ¨<br>' +
      '<b>å›å¾©ğŸ’š</b>ï¼ˆæŸãƒã‚®ï¼‰ã‚’ã‚¿ãƒƒãƒ—ã§ <b>ãƒ©ã‚¤ãƒ•+1</b>ï¼ˆæœ€å¤§7ï¼‰';

    // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
    let score = 0;
    let life = 7;
    let combo = 0;
    let gameRunning = false;

    let invincible = false;
    let invincibleTimeoutId = null;

    let leeks = [];
    let spawnTimerId = null;
    let moveTimerId = null;

    // ã‚³ãƒ³ãƒœ
    let comboTimer = null;
    const COMBO_WINDOW_MS = 1200;

    // å‡ºç¾/é›£æ˜“åº¦ï¼ˆæ³¢ï¼‰
    const BASE_SPAWN_INTERVAL = 650;
    const BASE_SPEED = 3.2;
    const WAVE_PERIOD_MS = 18000;
    const WAVE_MIN = 0.85;
    const WAVE_MAX = 1.40;
    let startTimeMs = 0;

    // å‡ºç¾ç‡ï¼ˆæ‚ªã„å¤šã‚ï¼‰
    const RATE = { good: 0.33, bad: 0.58, gold: 0.05, heal: 0.04 };

    // ã‚­ãƒªç•ªæ¼”å‡ºï¼ˆ20/50/â€¦/425ï¼‰
    const MILESTONES = [20, 50, 100, 150, 200, 250, 300, 350, 400, 425];
    let firedMilestones = new Set();

    // æœ€é«˜ã‚¹ã‚³ã‚¢ä¿å­˜
    const BEST_KEY = "negi_best_score";
    function loadBest() {
      const v = parseInt(localStorage.getItem(BEST_KEY) || "0", 10);
      return Number.isFinite(v) ? v : 0;
    }
    function saveBestIfNeeded() {
      const best = loadBest();
      if (score > best) localStorage.setItem(BEST_KEY, String(score));
      bestValueEl.textContent = String(Math.max(best, score));
    }

    // ====== è¡¨ç¤ºç³» ======
    function flashRuleMessage(html, ms = 900) {
      clearTimeout(flashRuleMessage._t);
      ruleTextEl.innerHTML = html;
      ruleTextEl.classList.add("rule-flash");
      flashRuleMessage._t = setTimeout(() => {
        ruleTextEl.classList.remove("rule-flash");
        ruleTextEl.innerHTML = DEFAULT_RULE_HTML;
      }, ms);
    }

    function showPop(text, clientX, clientY) {
      const rect = gameArea.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      const el = document.createElement("div");
      el.className = "pop";
      el.textContent = text;
      el.style.left = x + "px";
      el.style.top = y + "px";
      gameArea.appendChild(el);

      setTimeout(() => el.remove(), 800);
    }

    function setInvincible(on) {
      invincible = on;
      if (on) bodyEl.classList.add("invincible");
      else bodyEl.classList.remove("invincible");
    }

    function resetCombo() {
      clearTimeout(comboTimer);
      comboTimer = null;
      combo = 0;
      comboValueEl.textContent = "0";
    }

    function keepCombo() {
      clearTimeout(comboTimer);
      comboTimer = setTimeout(() => resetCombo(), COMBO_WINDOW_MS);
    }

    function setLife(newLife) {
      life = Math.max(0, Math.min(7, newLife));
      lifeValueEl.textContent = String(life);
      if (life <= 0) stopGame(true);
    }

    function handleMilestones(prev, now) {
      for (const m of MILESTONES) {
        if (m > prev && m <= now && !firedMilestones.has(m)) {
          firedMilestones.add(m);
          if (m === 425) {
            flashRuleMessage(`ğŸŒ¾ <b>425ç‚¹åˆ°é”ï¼</b><br>ç•‘ã®ç¥â€¦é™è‡¨âœ¨`, 1400);
          } else {
            flashRuleMessage(`ğŸ‰ <b>${m}ç‚¹ï¼åç©«ä¸Šæ‰‹ï¼</b>`, 1200);
          }
        }
      }
    }

    function updateScore(delta) {
      const prev = score;
      score += delta;
      if (score < 0) score = 0;
      scoreValueEl.textContent = String(score);

      // ãƒ—ãƒ©ã‚¹ç‚¹ã®æ™‚ã ã‘ã‚­ãƒªç•ªãƒã‚§ãƒƒã‚¯
      if (delta > 0) handleMilestones(prev, score);
    }

    function registerMiss(message) {
      if (invincible) {
        flashRuleMessage("ç„¡æ•µä¸­âœ¨ ã„ã¾ã®ãƒŸã‚¹ã¯ãƒãƒ¼ã‚«ã‚¦ãƒ³ãƒˆï¼", 900);
        return;
      }
      resetCombo();
      if (!invincible) updateScore(-1);
      setLife(life - 1);
      flashRuleMessage(`${message}<br>ãƒ©ã‚¤ãƒ•ãŒæ¸›ã£ãŸâ€¦ï¼ˆæ®‹ã‚Š <b>${life}</b>/7ï¼‰`, 1100);
    }

    // ====== æ³¢ ======
    function waveFactor(nowMs) {
      const t = (nowMs - startTimeMs) % WAVE_PERIOD_MS;
      const phase = (t / WAVE_PERIOD_MS) * Math.PI * 2;
      const s01 = (Math.sin(phase - Math.PI/2) + 1) / 2;
      return WAVE_MIN + (WAVE_MAX - WAVE_MIN) * s01;
    }

    // ====== å‡ºç¾ç¨®åˆ¥ ======
    function pickKind() {
      const r = Math.random();
      const a = RATE.good;
      const b = a + RATE.bad;
      const c = b + RATE.gold;
      if (r < a) return "good";
      if (r < b) return "bad";
      if (r < c) return "gold";
      return "heal";
    }

    // ====== ç”Ÿæˆ ======
    function spawnLeek() {
      if (!gameRunning) return;

      const kind = pickKind();
      const data = NEGI_TYPES[kind][Math.floor(Math.random() * NEGI_TYPES[kind].length)];

      const gameRect = gameArea.getBoundingClientRect();
      const yBottom = gameRect.height * 0.20;

      // wrapper
      const wrap = document.createElement("div");
      wrap.className = "leek-wrap" + (kind === "heal" ? " heal" : "");
      wrap.style.bottom = yBottom + "px";
      wrap.style.left = "-200px";

      // badge (heal only)
      const badge = document.createElement("div");
      badge.className = "heal-badge";
      badge.innerHTML = `å›å¾© <span class="heal-heart">ğŸ’š</span>`;
      wrap.appendChild(badge);

      // image
      const img = document.createElement("img");
      img.className = "leek-img";
      img.src = "images/" + data.file;
      img.alt = data.name;
      img.draggable = false;
      wrap.appendChild(img);

      const wf = waveFactor(performance.now());
      const base = BASE_SPEED * wf;

      let bonus = 0;
      if (kind === "good") bonus = 1.2;
      if (kind === "bad")  bonus = 0.8;
      if (kind === "gold") bonus = 0.2;
      if (kind === "heal") bonus = 0.2;

      const obj = {
        el: wrap,
        kind,
        name: data.name,
        x: -Math.max(200, gameRect.width * 0.35),
        speed: base + bonus + Math.random() * (2.8 * wf)
      };

      wrap.addEventListener("click", (e) => handleTapLeek(obj, e));
      wrap.addEventListener("touchend", (e) => {
        e.preventDefault();
        const t = e.changedTouches && e.changedTouches[0];
        handleTapLeek(obj, t || e);
      });

      gameArea.appendChild(wrap);
      leeks.push(obj);
    }

    function scheduleNextSpawn() {
      if (!gameRunning) return;
      const wf = waveFactor(performance.now());
      const interval = (BASE_SPAWN_INTERVAL / wf) * (0.85 + Math.random() * 0.35);

      spawnTimerId = setTimeout(() => {
        spawnLeek();
        scheduleNextSpawn();
      }, interval);
    }

    // ====== ç§»å‹• ======
    function moveLeeks() {
      if (!gameRunning) return;

      const gameRect = gameArea.getBoundingClientRect();
      const removeList = [];

      for (const obj of leeks) {
        obj.x += obj.speed;
        obj.el.style.left = obj.x + "px";

        if (obj.x > gameRect.width + 10) {
          handleLeekReachedRight(obj);
          removeList.push(obj);
        }
      }

      for (const obj of removeList) {
        obj.el.remove();
        const idx = leeks.indexOf(obj);
        if (idx >= 0) leeks.splice(idx, 1);
      }
    }

    function handleLeekReachedRight(obj) {
      if (obj.kind === "good") {
        updateScore(1);
      } else if (obj.kind === "bad") {
        registerMiss(`è¦‹é€ƒã—ï¼<b>${obj.name}</b>ãŒæµã‚Œã¡ã‚ƒã£ãŸğŸ’¦`);
      } else if (obj.kind === "gold") {
        updateScore(1);
      } else if (obj.kind === "heal") {
        // å›å¾©ã¯è¦‹é€ƒã—ã¦ã‚‚ãƒšãƒŠãƒ«ãƒ†ã‚£ãªã—
      }
    }

    // ====== ã‚¿ãƒƒãƒ—å‡¦ç† ======
    function handleTapLeek(obj, e) {
      if (!gameRunning) return;
      if (!gameArea.contains(obj.el)) return;

      const clientX = e && e.clientX ? e.clientX : (window.innerWidth / 2);
      const clientY = e && e.clientY ? e.clientY : (window.innerHeight / 2);

      if (obj.kind === "good") {
        registerMiss("ã¡ãŒã†ï¼è‰¯ã„ãƒã‚®ã‚’å–ã£ã¡ã‚ƒã£ãŸğŸ¥²");
        showPop(invincible ? "ã‚»ãƒ¼ãƒ•âœ¨" : "-1", clientX, clientY);
      }

      if (obj.kind === "bad") {
        combo += 1;
        comboValueEl.textContent = String(combo);
        keepCombo();

        updateScore(combo);
        showPop("+" + combo + "ğŸ‘Œ", clientX, clientY);
        flashRuleMessage(`ãƒŠã‚¤ã‚¹ï¼å‚·ã‚“ã ãƒã‚®ã‚’å‡¦ç†ğŸ‘Œ<br><b>${combo}ã‚³ãƒ³ãƒœï¼ +${combo}ç‚¹</b>`, 850);
      }

      if (obj.kind === "gold") {
        updateScore(10);
        showPop("+10âœ¨", clientX, clientY);

        flashRuleMessage("é‡‘ãƒã‚®ã‚²ãƒƒãƒˆï¼<br><b>5ç§’é–“ ãƒãƒ¼ãƒšãƒŠãƒ«ãƒ†ã‚£âœ¨</b>", 1100);
        setInvincible(true);
        clearTimeout(invincibleTimeoutId);
        invincibleTimeoutId = setTimeout(() => setInvincible(false), 5000);
      }

      if (obj.kind === "heal") {
        const before = life;
        if (before < 7) setLife(before + 1);
        showPop(before < 7 ? "ãƒ©ã‚¤ãƒ•+1ğŸ’š" : "æº€ã‚¿ãƒ³ğŸ’š", clientX, clientY);

        flashRuleMessage(
          before < 7
            ? "å›å¾©ãƒã‚®ï¼<br><b>ãƒ©ã‚¤ãƒ•ãŒ1å›å¾©ğŸ’š</b>"
            : "å›å¾©ãƒã‚®ï¼<br><b>ãƒ©ã‚¤ãƒ•ã¯æº€ã‚¿ãƒ³ğŸ’š</b>",
          1000
        );
      }

      obj.el.remove();
      const idx = leeks.indexOf(obj);
      if (idx >= 0) leeks.splice(idx, 1);
    }

    // ====== é–‹å§‹/çµ‚äº† ======
    function clearAllLeeks() {
      for (const obj of leeks) obj.el.remove();
      leeks = [];
    }

    function stopGameTimers() {
      clearTimeout(spawnTimerId);
      clearInterval(moveTimerId);
      spawnTimerId = null;
      moveTimerId = null;
    }

    function startGame() {
      // åˆæœŸåŒ–
      score = 0;
      life = 7;
      combo = 0;
      firedMilestones = new Set();

      scoreValueEl.textContent = "0";
      lifeValueEl.textContent = "7";
      comboValueEl.textContent = "0";

      setInvincible(false);
      clearTimeout(invincibleTimeoutId);

      clearAllLeeks();
      stopGameTimers();

      gameRunning = true;
      startTimeMs = performance.now();

      ruleTextEl.innerHTML = DEFAULT_RULE_HTML;

      mainBtn.textContent = "ãƒ—ãƒ¬ã‚¤ä¸­â€¦";
      mainBtn.disabled = true;

      scheduleNextSpawn();
      moveTimerId = setInterval(moveLeeks, 1000 / 60);

      flashRuleMessage("åç©«ã‚¹ã‚¿ãƒ¼ãƒˆï¼<br><b>æ‚ªã„ãƒã‚®ã‚’å©ã‘ãƒ¼ã£ğŸŒ¿</b>", 950);
    }

    function stopGame(isGameOver = false) {
      gameRunning = false;
      stopGameTimers();
      setInvincible(false);
      resetCombo();
      saveBestIfNeeded();

      const best = loadBest();

      if (isGameOver) {
        // ç•‘ã£ã½ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        ruleTextEl.innerHTML =
          `ğŸŒ™ åç©«ãŠã¤ã‹ã‚Œã•ã¾<br>` +
          `æœ€çµ‚ã‚¹ã‚³ã‚¢ï¼š<b>${score}</b><br>` +
          `æœ€é«˜ã‚¹ã‚³ã‚¢ï¼š<b>${best}</b>`;

        mainBtn.textContent = "ã‚‚ã†ä¸€åº¦åç©«ã™ã‚‹ï¼";
        mainBtn.disabled = false;
      } else {
        ruleTextEl.innerHTML = DEFAULT_RULE_HTML;
        mainBtn.textContent = "åç©«é–‹å§‹ï¼";
        mainBtn.disabled = false;
      }
    }

    // ====== ã‚¤ãƒ™ãƒ³ãƒˆ ======
    mainBtn.addEventListener("click", () => startGame());

    // åˆæœŸè¡¨ç¤º
    ruleTextEl.innerHTML = DEFAULT_RULE_HTML;
    bestValueEl.textContent = String(loadBest());
  </script>
</body>
</html>
